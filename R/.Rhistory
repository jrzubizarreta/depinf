library('designmatch')
bmatch
problemparameters
.problemparameters
library('designmatch')
bmatch
?bmatch
pmin(1:10, 4)
is.na(1:3)
if (is.na(1:3)) {#
		stop("The data needs to be sorted in decreasing order by the treatment indicator")#
	}
anyNA(1:4)
anyNA(c(1:4, NA))
depvar = function(x, d, GR, case = "heteroskedastic", solver = "glpk", approximate = 1) {#
#
	.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}#
	if (!is.null(GR)) {#
		if (case=="heteroskedastic") {#
			mx = mean(x)#
			v = outer(x-mx, x-mx)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}#
		if (case=="homoskedastic" & !is.null(GR)) {#
			n = length(x)#
			v = matrix(1, nrow=n, ncol=n)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}	#
	}#
	if (case=="heteroskedastic") {#
		V_hat = V1(A_max, x)#
	}#
	if (case=="homoskedastic" & !is.null(GR)) {#
		V_hat = V2(A_max, x)#
	}#
	if (case=="homoskedastic" & is.null(GR)) {#
		V_hat = V2p(d, x) #
	}#
	if (!is.null(GR)) {#
		return(list(V_hat = V_hat, A_max = A_max))#
	}#
	if (is.null(GR)) {#
		return(list(V_hat = V_hat))#
	}#
}
depgraph = function(v, d, GR, solver = "glpk", approximate = 1) {#
	n_tot = nrow(v)#
#
	n_dec = (n_tot*(n_tot-1))-sum(1:(n_tot-1))#
	cvec = t(v)[lower.tri(v)]#
	if (length(d)==1) {#
		rows_d_sca = rep(1, n_dec)#
		cols_d_sca = 1:n_dec	#
		vals_d_sca = rep(1, n_dec)	#
		row_count = max(rows_d_sca)#
	}#
	if (length(d)>1) {#
		rows_d_vec = sort(rep(1:n_tot, n_tot-1))#
		temp = matrix(0, nrow = n_tot, ncol = n_tot)#
		temp[lower.tri(temp)] = 1:n_dec#
		temp = temp+t(temp)#
		diag(temp) = NA#
		cols_d_vec = as.vector(t(temp))	#
		cols_d_vec = cols_d_vec[!is.na(cols_d_vec)]#
		vals_d_vec = rep(1, (n_tot-1)*n_tot)	#
		row_count = max(rows_d_vec)#
	}#
#
	if (!is.null(GR)) {#
		temp1 = GR[lower.tri(GR)]#
		cols_GR = which(temp1==1)#
		rows_GR = (row_count+1):(row_count+length(cols_GR)) #
		aux = rep(1, (n_tot-1)*n_tot)#
		vals_GR = aux[cols_GR] #
		row_count = max(rows_GR)#
	}#
	if (length(d)==1 & is.null(GR)) {#
		rows = c(rows_d_sca)#
		cols = c(cols_d_sca)#
		vals = c(vals_d_sca)#
		aux = cbind(rows, cols, vals)[order(cols), ]#
		cnstrn_mat = simple_triplet_matrix(i = aux[, 1], j = aux[, 2], v = aux[, 3])#
		Amat = cnstrn_mat#
	}#
	if (length(d)>1 & is.null(GR)) {#
		rows = c(rows_d_vec)#
		cols = c(cols_d_vec)#
		vals = c(vals_d_vec)#
		aux = cbind(rows, cols, vals)[order(cols), ]#
		cnstrn_mat = simple_triplet_matrix(i = aux[, 1], j = aux[, 2], v = aux[, 3])#
		Amat = cnstrn_mat#
	}#
	if (length(d)==1 & !is.null(GR)) {#
		rows = c(rows_d_sca, rows_GR)#
		cols = c(cols_d_sca, cols_GR)#
		vals = c(vals_d_sca, vals_GR)#
		aux = cbind(rows, cols, vals)[order(cols), ]#
		cnstrn_mat = simple_triplet_matrix(i = aux[, 1], j = aux[, 2], v = aux[, 3])#
		Amat = cnstrn_mat#
	}#
	if (length(d)>1 & !is.null(GR)) {#
		rows = c(rows_d_vec, rows_GR)#
		cols = c(cols_d_vec, cols_GR)#
		vals = c(vals_d_vec, vals_GR)#
		aux = cbind(rows, cols, vals)[order(cols), ]#
		cnstrn_mat = simple_triplet_matrix(i = aux[, 1], j = aux[, 2], v = aux[, 3])#
		Amat = cnstrn_mat#
	}#
	if (is.null(GR)) {#
		bvec = d#
	}#
	if (!is.null(GR)) {#
		bvec = c(d, rep(1, length(rows_GR)))	#
	}	#
	ub = rep(1, n_dec)#
	if (is.null(GR)) {#
		sense = rep("L", length(d))#
	}#
	if (!is.null(GR)) {#
		sense = c(rep("L", length(d)), rep("E", length(rows_GR)))	#
	}#
	if (approximate == 1) {#
		var_type = rep("C", n_dec)#
	}#
	else if (approximate == 0) {#
		var_type = rep("B", n_dec)#
	}#
	if (solver=="cplex") {#
		library("Rcplex")#
#
		ptm = proc.time()#
		out = Rcplex(cvec, Amat, bvec, ub = ub, sense = sense, vtype = var_type, objsense = "max", control = list(trace = 0, round = 1))#
		time = (proc.time()-ptm)[3]#
		i_ind = rep(1:(n_tot-1), (n_tot-1):1)	#
		aux = matrix(1:n_tot, nrow = n_tot, ncol = n_tot)#
		j_ind = aux[lower.tri(aux)]#
#
		if (approximate == 1) {#
			group_1 = i_ind[out$xopt!=0]#
			group_2 = j_ind[out$xopt!=0]#
			approx_sol = out$xopt#
		}#
		else if (approximate == 0) {#
			group_1 = i_ind[out$xopt==1]#
			group_2 = j_ind[out$xopt==1]#
		}#
		obj_val = out$obj	#
	}#
	if (solver=="gurobi") {#
		library("gurobi")#
#
		model = list()#
		model$obj = cvec#
		model$A = Amat#
		model$sense = rep(NA, length(sense))#
		model$sense[sense=="E"] = '='#
		model$sense[sense=="L"] = '<='#
		model$sense[sense=="G"] = '>='#
		model$rhs = bvec#
		model$vtype = var_type#
		model$ub = ub#
		model$modelsense = "max"#
		ptm = proc.time()#
		out = gurobi(model)#
		time = (proc.time()-ptm)[3]#
		i_ind = rep(1:(n_tot-1), (n_tot-1):1)	#
		aux = matrix(1:n_tot, nrow = n_tot, ncol = n_tot)#
		j_ind = aux[lower.tri(aux)]#
#
		if (approximate == 1) {#
			group_1 = i_ind[out$x!=0]#
			group_2 = j_ind[out$x!=0]#
			approx_sol = out$x#
		}#
		else if (approximate == 0) {#
			group_1 = i_ind[out$x==1]#
			group_2 = j_ind[out$x==1]#
		}#
		obj_val = out$obj#
	}#
	if (solver=="glpk") {#
		library("Rglpk")#
#
    	dir = rep(NA, length(sense))#
    	dir[sense=="E"] = '=='#
    	dir[sense=="L"] = '<='#
    	dir[sense=="G"] = '>='#
   		bound = list(lower = list(ind=c(1:length(ub)), val=rep(0,length(ub))), upper = list(ind=c(1:length(ub)), val=ub))#
   		ptm = proc.time()#
    	out = Rglpk_solve_LP(cvec, Amat, dir, bvec, bounds = bound, types = var_type, max = TRUE)#
    	time = (proc.time()-ptm)[3]#
#
		i_ind = rep(1:(n_tot-1), (n_tot-1):1)	#
		aux = matrix(1:n_tot, nrow = n_tot, ncol = n_tot)#
		j_ind = aux[lower.tri(aux)]#
#
		if (approximate == 1) {#
			group_1 = i_ind[out$solution!=0]#
			group_2 = j_ind[out$solution!=0]#
			approx_sol = out$solution#
		}#
		else if (approximate == 0) {#
			group_1 = i_ind[out$solution==1]#
			group_2 = j_ind[out$solution==1]#
		}#
    	obj_val = out$optimum#
	}	#
#
	if (approximate == 1) {#
		aux = matrix(0, nrow=n, ncol=n)#
		aux[cbind(group_1, group_2)] = approx_sol[approx_sol!=0]#
		A_max = aux+t(aux)#
	}#
	else if (approximate == 0) {#
		max_groups = apply(cbind(group_1, group_2), 1, max)#
		id_1 = group_1[max_groups<=n_tot]#
		id_2 = group_2[max_groups<=n_tot]#
		aux = matrix(0, nrow=n, ncol=n)#
		aux[cbind(id_1, id_2)] = 1#
		A_max = aux+t(aux)#
	}#
	return = list(A_max = A_max, obj_val = obj_val, time = time)#
}
# Example with 100 nodes#
data(example)#
#
# Total number of observations#
n = nrow(dat)#
#
# Observed data #
# Observed dependencies (observed (known) a_ij's; this is A_R in (5) in the paper)#
GR = GR#
# Observed degrees#
d = dat$degree#
# Observed outcomes#
x = dat$hiv
load("/Users/jrz/Documents/Dropbox/research/projects/39_knapsack/11_package/03_22jan16/depinf/data/example.rda")
n = nrow(dat)
# Observed data #
# Observed dependencies (observed (known) a_ij's; this is A_R in (5) in the paper)#
GR = GR#
# Observed degrees#
d = dat$degree#
# Observed outcomes#
x = dat$hiv
depvar(x, d, GR = NULL, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
.errorhandle = function(x, d, GR, case, solver, approximate) { #
#
	if (anyNA(x)) {#
		stop("There cannot be NAs in x")#
	}#
}
depvar(x, d, GR = NULL, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}
case
case = "heteroskedastic"
solver = "glpk"
approximate = 1
library("Rglpk")
.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}#
	if (!is.null(GR)) {#
		if (case=="heteroskedastic") {#
			mx = mean(x)#
			v = outer(x-mx, x-mx)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}#
		if (case=="homoskedastic" & !is.null(GR)) {#
			n = length(x)#
			v = matrix(1, nrow=n, ncol=n)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}	#
	}
case
A_max
.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}#
	if (!is.null(GR)) {#
		if (case=="heteroskedastic") {#
			mx = mean(x)#
			v = outer(x-mx, x-mx)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}#
		if (case=="homoskedastic" & !is.null(GR)) {#
			n = length(x)#
			v = matrix(1, nrow=n, ncol=n)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}	#
	}
if (case=="heteroskedastic") {#
		V_hat = V1(A_max, x)#
	}#
	if (case=="homoskedastic" & !is.null(GR)) {#
		V_hat = V2(A_max, x)#
	}#
	if (case=="homoskedastic" & is.null(GR)) {#
		V_hat = V2p(d, x) #
	}
if (!is.null(GR)) {#
		return(list(V_hat = V_hat, A_max = A_max))#
	}#
	if (is.null(GR)) {#
		return(list(V_hat = V_hat))#
	}
rm(_Amat)
rm(A_mat)
rm(A_max)
depvar(x, d, GR = NULL, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}#
	if (!is.null(GR)) {#
		if (case=="heteroskedastic") {#
			mx = mean(x)#
			v = outer(x-mx, x-mx)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}#
		if (case=="homoskedastic" & !is.null(GR)) {#
			n = length(x)#
			v = matrix(1, nrow=n, ncol=n)#
			out = depgraph(v, d, GR, solver, approximate)#
			A_max = out$A_max#
		}	#
	}#
	if (case=="heteroskedastic") {#
		V_hat = V1(A_max, x)#
	}#
	if (case=="homoskedastic" & !is.null(GR)) {#
		V_hat = V2(A_max, x)#
	}#
	if (case=="homoskedastic" & is.null(GR)) {#
		V_hat = V2p(d, x) #
	}
depvar(x, d, GR, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
out = depgraph(v, d, GR, solver, approximate)
GR
depvar = function(x, d, GR, case = "heteroskedastic", solver = "glpk", approximate = 1) {#
#
	.errorhandle(x, d, GR, case, solver, approximate)#
	# Estimator V_1 in the paper#
	V1 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V1_hat = as.numeric( var(x)/n + (t(x-mx) %*% A %*% (x-mx))/(n^2) )#
		return(V1_hat) #
	}#
#
	# Estimator V_2 in the paper#
	V2 = function(A, x) {#
		mx = mean(x)#
		n = nrow(A)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(A)/n) )#
		return(V2_hat) #
	}#
	# Estimator V_2' in the paper#
	V2p = function(d, x) {#
		mx = mean(x)#
		n = length(d)#
		V2_hat = as.numeric( var(x)/n * (1 + sum(pmin(d, n-1))/n) )#
		return(V2_hat) #
	}#
	if (case=="heteroskedastic") {#
		mx = mean(x)#
		v = outer(x-mx, x-mx)#
		out = depgraph(v, d, GR, solver, approximate)#
		A_max = out$A_max#
	}#
	if (case=="homoskedastic" & !is.null(GR)) {#
		n = length(x)#
		v = matrix(1, nrow=n, ncol=n)#
		out = depgraph(v, d, GR, solver, approximate)#
		A_max = out$A_max#
	}	#
	if (case=="heteroskedastic") {#
		V_hat = V1(A_max, x)#
	}#
	if (case=="homoskedastic" & !is.null(GR)) {#
		V_hat = V2(A_max, x)#
	}#
	if (case=="homoskedastic" & is.null(GR)) {#
		V_hat = V2p(d, x) #
	}#
	if (!is.null(GR)) {#
		return(list(V_hat = V_hat, A_max = A_max))#
	}#
	if (is.null(GR)) {#
		return(list(V_hat = V_hat))#
	}#
}
depvar(x, d, GR = NULL, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
depvar(x, d, GR, case = "heteroskedastic", solver = "glpk", approximate = 1)$V_hat
depvar(x, d, GR, case = "homoskedastic", solver = "glpk", approximate = 1)$V_hat
depvar(x, d, GR = NULL, case = "homoskedastic")$V_hat
var(x)/n * (1 + sum(pmin(d, n-1))/n)
(1:3)*(1:3)
